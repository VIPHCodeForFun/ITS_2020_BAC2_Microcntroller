/*
 * timer_hal.c
 *
 * Created: 01.07.2023 17:43:40
 *  Author: Philipp Vidmar
 */

#include "hal/timer-hal.h"

void setupTime()
{
	/*-- Setup Timer2 --*/
	*RCC_APB1ENR |= (uint32_t)(1 << 0); // TIM2EN: TIM2 timer clock enable 	RM0316_Reference_manual p.154

	// TIMx_CR1: UIFREMAP = 0 No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
	// TIMx_CR1: CKD = 00 	Clock division
	// TIMx_CR1: ARPE = 0 	TIMx_ARR register is not buffered
	// TIMx_CR1: CMS= 00	Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
	// TIMx_CR1: DIR = 0	Counter used as upcounter
	// TIMx_CR1: OPM = 0 Counter is not stopped at update event
	// TIMx_CR1: URS = 0: Any of the following events generate an update interrupt or DMA request if enabled.
/*These events can be:
* – Counter overflow/underflow
* – Setting the UG bit
* – Update generation through the slave mode controller
*/
	// TIMx_CR1: UDIS = 0 UEV enabled. The Update (UEV) event is generated by one of the following events:
/*
 * – Counter overflow/underflow
 * – Setting the UG bit
 * – Update generation through the slave mode controller*/
	//BIT_SET_PTR(TIME2_CR1,0); // CEN: Counter enable RM0316_Reference_manual p.648

	//TIMx_CR2: TI1S = 0 The TIMx_CH1 pin is connected to TI1 input
	//TIMx_CR2: MMS[2:0] = 000 Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO).
/*
If the reset is generated by the trigger input (slave mode controller configured in reset mode) then
the signal on TRGO is delayed compared to the actual reset.
*/
	//TIMx_CR2: CCDS = 0 CCx DMA request sent when CCx event occurs

	*TIM2_PSC = 80;				// Set Prescaler p.664


}

uint32_t milliSeconds()
{


}

void delayMilliSeconds(uint32_t milliSekondsDelay){
	/* Create Timestamp */
	uint32_t timeStamp = milliSeconds() + milliSekondsDelay;
	while (timeStamp > milliSeconds()){
		// Wait till Timestamp is reached
	}
}
